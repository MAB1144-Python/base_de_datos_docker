# GUÍA DE EJEMPLOS SQL PARA ESTUDIANTES
# ======================================
# Sistema de Consultas SQL - Ejemplos Prácticos
# Curso de Base de Datos - Universidad
# ======================================

## TABLA DE CONTENIDOS
1. Conceptos Básicos de SQL
2. Consultas SELECT Fundamentales
3. Filtros y Condiciones
4. Ordenamiento y Límites
5. Funciones de Agregación
6. Agrupamiento de Datos
7. Consultas con Múltiples Tablas (JOINs)
8. Subconsultas
9. Modificación de Datos (INSERT, UPDATE, DELETE)
10. Casos de Uso Empresariales

===============================================================================

## 1. CONCEPTOS BÁSICOS DE SQL

### ¿Qué es SQL?
SQL (Structured Query Language) es el lenguaje estándar para trabajar con bases de datos relacionales.

### Tipos de Comandos SQL:
- DDL (Data Definition Language): CREATE, ALTER, DROP
- DML (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
- DCL (Data Control Language): GRANT, REVOKE

### Estructura Básica de una Consulta SELECT:
```
SELECT columnas
FROM tabla
WHERE condiciones
GROUP BY columnas_agrupacion
HAVING condiciones_grupo
ORDER BY columnas_ordenamiento
LIMIT número_filas;
```

### Reglas Importantes:
- Las consultas SQL terminan con punto y coma (;)
- SQL no es sensible a mayúsculas/minúsculas (pero es buena práctica usar mayúsculas para palabras clave)
- Los nombres de tablas y columnas SÍ pueden ser sensibles dependiendo del sistema
- Las cadenas de texto van entre comillas simples ('texto')

===============================================================================

## 2. CONSULTAS SELECT FUNDAMENTALES

### Ejemplo 2.1: Seleccionar todas las columnas
```sql
-- Obtener todos los datos de la tabla usuarios
SELECT * FROM usuarios;
```
RESULTADO ESPERADO: Todas las filas y columnas de la tabla usuarios
EXPLICACIÓN: El asterisco (*) significa "todas las columnas"

### Ejemplo 2.2: Seleccionar columnas específicas
```sql
-- Obtener solo nombres y emails de usuarios
SELECT nombre, email FROM usuarios;
```
RESULTADO ESPERADO: Solo las columnas nombre y email
EXPLICACIÓN: Especificamos exactamente qué columnas queremos ver

### Ejemplo 2.3: Usar alias para columnas
```sql
-- Usar nombres más descriptivos para las columnas
SELECT 
    nombre AS 'Nombre Completo',
    email AS 'Correo Electrónico',
    edad AS 'Años'
FROM usuarios;
```
RESULTADO ESPERADO: Las mismas columnas pero con nombres diferentes
EXPLICACIÓN: AS permite cambiar el nombre que se muestra en los resultados

### Ejemplo 2.4: Eliminar duplicados
```sql
-- Obtener las edades únicas (sin repetir)
SELECT DISTINCT edad FROM usuarios;
```
RESULTADO ESPERADO: Cada edad aparece solo una vez
EXPLICACIÓN: DISTINCT elimina valores duplicados

===============================================================================

## 3. FILTROS Y CONDICIONES

### Ejemplo 3.1: Condición simple con WHERE
```sql
-- Usuarios mayores de 25 años
SELECT nombre, edad 
FROM usuarios 
WHERE edad > 25;
```
RESULTADO ESPERADO: Solo usuarios cuya edad sea mayor a 25
EXPLICACIÓN: WHERE permite filtrar filas basándose en condiciones

### Ejemplo 3.2: Múltiples condiciones con AND
```sql
-- Usuarios mayores de 25 años Y cuyo nombre contenga 'Ana'
SELECT * 
FROM usuarios 
WHERE edad > 25 AND nombre LIKE '%Ana%';
```
RESULTADO ESPERADO: Usuarios que cumplan AMBAS condiciones
EXPLICACIÓN: AND requiere que se cumplan todas las condiciones

### Ejemplo 3.3: Condiciones alternativas con OR
```sql
-- Usuarios menores de 25 años O mayores de 30
SELECT nombre, edad 
FROM usuarios 
WHERE edad < 25 OR edad > 30;
```
RESULTADO ESPERADO: Usuarios que cumplan AL MENOS una condición
EXPLICACIÓN: OR requiere que se cumpla cualquiera de las condiciones

### Ejemplo 3.4: Búsqueda con patrones (LIKE)
```sql
-- Usuarios cuyo email termina en '.com'
SELECT nombre, email 
FROM usuarios 
WHERE email LIKE '%.com';
```
RESULTADO ESPERADO: Solo usuarios con emails que terminen en .com
EXPLICACIÓN: 
- % representa cualquier cantidad de caracteres
- _ representa exactamente un carácter

### Ejemplo 3.5: Valores en una lista (IN)
```sql
-- Productos de categorías específicas
SELECT nombre, categoria 
FROM productos 
WHERE categoria IN ('Electrónicos', 'Accesorios');
```
RESULTADO ESPERADO: Solo productos de esas dos categorías
EXPLICACIÓN: IN es equivalente a múltiples OR

### Ejemplo 3.6: Rango de valores (BETWEEN)
```sql
-- Productos con precios entre 50 y 200
SELECT nombre, precio 
FROM productos 
WHERE precio BETWEEN 50 AND 200;
```
RESULTADO ESPERADO: Productos con precio desde 50 hasta 200 (inclusive)
EXPLICACIÓN: BETWEEN incluye los valores límite

### Ejemplo 3.7: Valores nulos
```sql
-- Productos sin categoría definida
SELECT nombre, categoria 
FROM productos 
WHERE categoria IS NULL;

-- Productos con categoría definida
SELECT nombre, categoria 
FROM productos 
WHERE categoria IS NOT NULL;
```
RESULTADO ESPERADO: Primera consulta muestra productos sin categoría, segunda con categoría
EXPLICACIÓN: NULL representa ausencia de valor, no se puede usar = o !=

===============================================================================

## 4. ORDENAMIENTO Y LÍMITES

### Ejemplo 4.1: Ordenamiento ascendente
```sql
-- Usuarios ordenados por edad (menor a mayor)
SELECT nombre, edad 
FROM usuarios 
ORDER BY edad;
```
RESULTADO ESPERADO: Usuarios listados de menor a mayor edad
EXPLICACIÓN: ORDER BY ordena ascendente por defecto

### Ejemplo 4.2: Ordenamiento descendente
```sql
-- Productos ordenados por precio (mayor a menor)
SELECT nombre, precio 
FROM productos 
ORDER BY precio DESC;
```
RESULTADO ESPERADO: Productos del más caro al más barato
EXPLICACIÓN: DESC indica orden descendente

### Ejemplo 4.3: Ordenamiento múltiple
```sql
-- Productos ordenados por categoría y luego por precio
SELECT nombre, categoria, precio 
FROM productos 
ORDER BY categoria, precio DESC;
```
RESULTADO ESPERADO: Agrupados por categoría, dentro de cada categoría del más caro al más barato
EXPLICACIÓN: Se puede ordenar por múltiples columnas

### Ejemplo 4.4: Limitar resultados
```sql
-- Los 3 productos más caros
SELECT nombre, precio 
FROM productos 
ORDER BY precio DESC 
LIMIT 3;
```
RESULTADO ESPERADO: Solo los 3 productos con mayor precio
EXPLICACIÓN: LIMIT restringe el número de filas devueltas

### Ejemplo 4.5: Paginación con OFFSET
```sql
-- Productos del 4 al 6 más caros (página 2, 3 productos por página)
SELECT nombre, precio 
FROM productos 
ORDER BY precio DESC 
LIMIT 3 OFFSET 3;
```
RESULTADO ESPERADO: Los productos en las posiciones 4, 5 y 6
EXPLICACIÓN: OFFSET salta las primeras N filas

===============================================================================

## 5. FUNCIONES DE AGREGACIÓN

### Ejemplo 5.1: Contar registros (COUNT)
```sql
-- Total de usuarios en el sistema
SELECT COUNT(*) AS total_usuarios 
FROM usuarios;

-- Usuarios con email definido
SELECT COUNT(email) AS usuarios_con_email 
FROM usuarios;
```
RESULTADO ESPERADO: Primera consulta cuenta todas las filas, segunda solo las que tienen email
EXPLICACIÓN: COUNT(*) cuenta filas, COUNT(columna) cuenta valores no nulos

### Ejemplo 5.2: Suma (SUM)
```sql
-- Stock total de todos los productos
SELECT SUM(stock) AS stock_total 
FROM productos;

-- Valor total del inventario
SELECT SUM(precio * stock) AS valor_inventario 
FROM productos;
```
RESULTADO ESPERADO: Primera consulta suma el stock, segunda calcula el valor total
EXPLICACIÓN: SUM solo funciona con columnas numéricas

### Ejemplo 5.3: Promedio (AVG)
```sql
-- Edad promedio de los usuarios
SELECT AVG(edad) AS edad_promedio 
FROM usuarios;

-- Precio promedio por categoría
SELECT categoria, AVG(precio) AS precio_promedio 
FROM productos 
GROUP BY categoria;
```
RESULTADO ESPERADO: Primera consulta da un solo promedio, segunda un promedio por categoría
EXPLICACIÓN: AVG calcula la media aritmética

### Ejemplo 5.4: Valores mínimo y máximo (MIN, MAX)
```sql
-- Usuario más joven y más viejo
SELECT 
    MIN(edad) AS edad_minima,
    MAX(edad) AS edad_maxima 
FROM usuarios;

-- Producto más barato y más caro por categoría
SELECT 
    categoria,
    MIN(precio) AS precio_minimo,
    MAX(precio) AS precio_maximo 
FROM productos 
GROUP BY categoria;
```
RESULTADO ESPERADO: Los valores extremos en las columnas especificadas
EXPLICACIÓN: MIN y MAX encuentran los valores extremos

===============================================================================

## 6. AGRUPAMIENTO DE DATOS

### Ejemplo 6.1: GROUP BY básico
```sql
-- Número de usuarios por edad
SELECT edad, COUNT(*) AS cantidad 
FROM usuarios 
GROUP BY edad 
ORDER BY edad;
```
RESULTADO ESPERADO: Cada edad con su cantidad de usuarios
EXPLICACIÓN: GROUP BY agrupa filas con el mismo valor y permite aplicar funciones de agregación

### Ejemplo 6.2: Múltiples columnas de agrupación
```sql
-- Estadísticas por categoría y rango de precio
SELECT 
    categoria,
    CASE 
        WHEN precio < 100 THEN 'Económico'
        WHEN precio < 300 THEN 'Medio'
        ELSE 'Premium'
    END AS rango_precio,
    COUNT(*) AS cantidad,
    AVG(precio) AS precio_promedio
FROM productos 
GROUP BY categoria, 
    CASE 
        WHEN precio < 100 THEN 'Económico'
        WHEN precio < 300 THEN 'Medio'
        ELSE 'Premium'
    END
ORDER BY categoria, precio_promedio;
```
RESULTADO ESPERADO: Estadísticas detalladas por categoría y rango de precio
EXPLICACIÓN: Se puede agrupar por expresiones calculadas

### Ejemplo 6.3: Filtrar grupos con HAVING
```sql
-- Categorías con más de 2 productos
SELECT categoria, COUNT(*) AS cantidad_productos 
FROM productos 
GROUP BY categoria 
HAVING COUNT(*) > 2;
```
RESULTADO ESPERADO: Solo las categorías que tienen más de 2 productos
EXPLICACIÓN: HAVING filtra grupos (después de GROUP BY), WHERE filtra filas individuales

### Ejemplo 6.4: Combinando WHERE y HAVING
```sql
-- Categorías con más de 1 producto caro (>100)
SELECT categoria, COUNT(*) AS productos_caros 
FROM productos 
WHERE precio > 100 
GROUP BY categoria 
HAVING COUNT(*) > 1;
```
RESULTADO ESPERADO: Categorías que tienen más de un producto caro
EXPLICACIÓN: WHERE filtra antes de agrupar, HAVING filtra después de agrupar

===============================================================================

## 7. CONSULTAS CON MÚLTIPLES TABLAS (JOINs)

### Conceptos de JOINs:
- INNER JOIN: Solo filas que tienen coincidencia en ambas tablas
- LEFT JOIN: Todas las filas de la tabla izquierda + coincidencias de la derecha
- RIGHT JOIN: Todas las filas de la tabla derecha + coincidencias de la izquierda
- FULL JOIN: Todas las filas de ambas tablas

### Ejemplo 7.1: INNER JOIN básico
```sql
-- Ventas con información de usuarios y productos
SELECT 
    u.nombre AS cliente,
    p.nombre AS producto,
    v.cantidad,
    v.fecha_venta
FROM ventas v
INNER JOIN usuarios u ON v.usuario_id = u.id
INNER JOIN productos p ON v.producto_id = p.id;
```
RESULTADO ESPERADO: Solo las ventas que tienen usuario y producto válidos
EXPLICACIÓN: INNER JOIN combina filas que tienen coincidencia en las claves foráneas

### Ejemplo 7.2: LEFT JOIN para incluir todos los usuarios
```sql
-- Todos los usuarios y sus compras (incluso los que no han comprado)
SELECT 
    u.nombre,
    u.email,
    COUNT(v.id) AS numero_compras,
    COALESCE(SUM(p.precio * v.cantidad), 0) AS total_gastado
FROM usuarios u
LEFT JOIN ventas v ON u.id = v.usuario_id
LEFT JOIN productos p ON v.producto_id = p.id
GROUP BY u.id, u.nombre, u.email
ORDER BY total_gastado DESC;
```
RESULTADO ESPERADO: Todos los usuarios, con 0 compras para los que no han comprado
EXPLICACIÓN: LEFT JOIN incluye todas las filas de la tabla izquierda (usuarios)

### Ejemplo 7.3: Análisis de ventas completo
```sql
-- Reporte detallado de ventas con márgenes
SELECT 
    v.id AS venta_id,
    u.nombre AS cliente,
    u.edad AS edad_cliente,
    p.nombre AS producto,
    p.categoria,
    p.precio AS precio_unitario,
    v.cantidad,
    (p.precio * v.cantidad) AS total_venta,
    v.fecha_venta,
    CASE 
        WHEN p.precio > 500 THEN 'Alto valor'
        WHEN p.precio > 100 THEN 'Valor medio'
        ELSE 'Valor básico'
    END AS tipo_venta
FROM ventas v
JOIN usuarios u ON v.usuario_id = u.id
JOIN productos p ON v.producto_id = p.id
WHERE v.fecha_venta >= DATE('now', '-30 days')
ORDER BY total_venta DESC;
```
RESULTADO ESPERADO: Análisis detallado de ventas de los últimos 30 días
EXPLICACIÓN: Combina múltiples tablas y agrega información calculada

### Ejemplo 7.4: Encontrar productos sin ventas
```sql
-- Productos que nunca se han vendido
SELECT 
    p.nombre,
    p.precio,
    p.categoria,
    p.stock
FROM productos p
LEFT JOIN ventas v ON p.id = v.producto_id
WHERE v.producto_id IS NULL;
```
RESULTADO ESPERADO: Productos que no aparecen en la tabla de ventas
EXPLICACIÓN: LEFT JOIN + IS NULL encuentra filas sin coincidencia

===============================================================================

## 8. SUBCONSULTAS

### Ejemplo 8.1: Subconsulta en WHERE
```sql
-- Usuarios que han gastado más que el promedio
SELECT nombre, email
FROM usuarios u
WHERE u.id IN (
    SELECT v.usuario_id
    FROM ventas v
    JOIN productos p ON v.producto_id = p.id
    GROUP BY v.usuario_id
    HAVING SUM(p.precio * v.cantidad) > (
        SELECT AVG(p.precio * v.cantidad)
        FROM ventas v
        JOIN productos p ON v.producto_id = p.id
    )
);
```
RESULTADO ESPERADO: Usuarios con gastos superiores al promedio
EXPLICACIÓN: Subconsulta calcula el promedio, consulta principal lo usa como filtro

### Ejemplo 8.2: Subconsulta en SELECT
```sql
-- Productos con su posición en ranking de precios
SELECT 
    nombre,
    precio,
    categoria,
    (SELECT COUNT(*) 
     FROM productos p2 
     WHERE p2.precio > p.precio) + 1 AS ranking_precio
FROM productos p
ORDER BY precio DESC;
```
RESULTADO ESPERADO: Cada producto con su posición en el ranking de precios
EXPLICACIÓN: La subconsulta cuenta cuántos productos son más caros

### Ejemplo 8.3: Subconsulta correlacionada
```sql
-- Productos más caros en cada categoría
SELECT nombre, precio, categoria
FROM productos p1
WHERE precio = (
    SELECT MAX(precio)
    FROM productos p2
    WHERE p2.categoria = p1.categoria
);
```
RESULTADO ESPERADO: El producto más caro de cada categoría
EXPLICACIÓN: La subconsulta se ejecuta para cada fila de la consulta principal

===============================================================================

## 9. MODIFICACIÓN DE DATOS

### Ejemplo 9.1: INSERT - Insertar datos
```sql
-- Agregar un nuevo usuario
INSERT INTO usuarios (nombre, email, edad) 
VALUES ('Pedro Ramírez', 'pedro.ramirez@email.com', 28);

-- Insertar múltiples registros
INSERT INTO productos (nombre, precio, categoria, stock) 
VALUES 
    ('Tablet', 299.99, 'Electrónicos', 15),
    ('Auriculares', 79.99, 'Accesorios', 30),
    ('Webcam', 59.99, 'Accesorios', 20);
```
RESULTADO ESPERADO: Nuevos registros agregados a las tablas
EXPLICACIÓN: INSERT agrega nuevas filas a la tabla

### Ejemplo 9.2: UPDATE - Actualizar datos
```sql
-- Actualizar precio de un producto específico
UPDATE productos 
SET precio = 849.99 
WHERE nombre = 'Laptop';

-- Actualizar múltiples columnas
UPDATE productos 
SET precio = precio * 0.9, stock = stock + 10 
WHERE categoria = 'Electrónicos';

-- Actualización condicional
UPDATE usuarios 
SET edad = edad + 1 
WHERE fecha_registro <= DATE('now', '-1 year');
```
RESULTADO ESPERADO: Registros existentes modificados según las condiciones
EXPLICACIÓN: UPDATE modifica filas existentes, WHERE determina cuáles

### Ejemplo 9.3: DELETE - Eliminar datos
```sql
-- Eliminar un usuario específico
DELETE FROM usuarios 
WHERE email = 'usuario@eliminar.com';

-- Eliminar productos sin stock
DELETE FROM productos 
WHERE stock = 0;

-- Eliminar ventas antiguas (¡CUIDADO! Usar con precaución)
DELETE FROM ventas 
WHERE fecha_venta < DATE('now', '-2 years');
```
RESULTADO ESPERADO: Filas eliminadas de la tabla
EXPLICACIÓN: DELETE elimina filas permanentemente, siempre usar WHERE

⚠️ ADVERTENCIA: Los comandos DELETE y UPDATE son irreversibles. Siempre:
1. Haz backup antes de operaciones masivas
2. Prueba la condición WHERE con SELECT primero
3. Comienza con un LIMIT pequeño

===============================================================================

## 10. CASOS DE USO EMPRESARIALES

### Caso 10.1: Dashboard de Ventas
```sql
-- Métricas clave del negocio
SELECT 
    COUNT(DISTINCT v.usuario_id) AS clientes_activos,
    COUNT(v.id) AS total_ventas,
    SUM(p.precio * v.cantidad) AS ingresos_totales,
    AVG(p.precio * v.cantidad) AS venta_promedio,
    (SELECT COUNT(*) FROM productos WHERE stock > 0) AS productos_disponibles
FROM ventas v
JOIN productos p ON v.producto_id = p.id
WHERE v.fecha_venta >= DATE('now', '-30 days');
```

### Caso 10.2: Análisis de Inventario
```sql
-- Productos que necesitan reabastecimiento
SELECT 
    p.nombre,
    p.categoria,
    p.stock AS stock_actual,
    COALESCE(SUM(v.cantidad), 0) AS total_vendido,
    CASE 
        WHEN p.stock < 5 THEN 'CRÍTICO'
        WHEN p.stock < 15 THEN 'BAJO'
        ELSE 'NORMAL'
    END AS estado_stock
FROM productos p
LEFT JOIN ventas v ON p.id = v.producto_id 
    AND v.fecha_venta >= DATE('now', '-30 days')
GROUP BY p.id, p.nombre, p.categoria, p.stock
ORDER BY p.stock ASC, total_vendido DESC;
```

### Caso 10.3: Segmentación de Clientes
```sql
-- Clasificar clientes por valor
WITH cliente_stats AS (
    SELECT 
        u.id,
        u.nombre,
        u.email,
        u.edad,
        COUNT(v.id) AS total_compras,
        SUM(p.precio * v.cantidad) AS total_gastado,
        AVG(p.precio * v.cantidad) AS gasto_promedio,
        MAX(v.fecha_venta) AS ultima_compra
    FROM usuarios u
    LEFT JOIN ventas v ON u.id = v.usuario_id
    LEFT JOIN productos p ON v.producto_id = p.id
    GROUP BY u.id, u.nombre, u.email, u.edad
)
SELECT 
    nombre,
    email,
    total_compras,
    total_gastado,
    CASE 
        WHEN total_gastado >= 1000 THEN 'VIP'
        WHEN total_gastado >= 500 THEN 'Premium'
        WHEN total_gastado >= 100 THEN 'Regular'
        WHEN total_gastado > 0 THEN 'Básico'
        ELSE 'Sin compras'
    END AS segmento,
    CASE 
        WHEN ultima_compra >= DATE('now', '-30 days') THEN 'Activo'
        WHEN ultima_compra >= DATE('now', '-90 days') THEN 'Inactivo reciente'
        WHEN ultima_compra IS NOT NULL THEN 'Inactivo'
        ELSE 'Sin actividad'
    END AS estado_actividad
FROM cliente_stats
ORDER BY total_gastado DESC;
```

### Caso 10.4: Reporte de Tendencias
```sql
-- Ventas mensuales con crecimiento
SELECT 
    strftime('%Y-%m', fecha_venta) AS mes,
    COUNT(*) AS num_ventas,
    SUM(p.precio * v.cantidad) AS ingresos,
    AVG(p.precio * v.cantidad) AS ticket_promedio,
    COUNT(DISTINCT v.usuario_id) AS clientes_unicos
FROM ventas v
JOIN productos p ON v.producto_id = p.id
WHERE v.fecha_venta >= DATE('now', '-12 months')
GROUP BY strftime('%Y-%m', fecha_venta)
ORDER BY mes;
```

===============================================================================

## CONSEJOS Y MEJORES PRÁCTICAS

### 📝 Escritura de Consultas:
1. **Usa indentación** para hacer el código legible
2. **Comenta consultas complejas** con -- o /* */
3. **Usa alias descriptivos** para tablas y columnas
4. **Mayúsculas para palabras clave** SQL (SELECT, FROM, WHERE)

### ⚡ Optimización:
1. **Usa índices** en columnas de búsqueda frecuente
2. **Evita SELECT *** en tablas grandes
3. **Usa LIMIT** para pruebas en tablas grandes
4. **Filtra antes de hacer JOINs** cuando sea posible

### 🛡️ Seguridad:
1. **Nunca DELETE o UPDATE sin WHERE** en producción
2. **Prueba consultas destructivas** en copias de datos
3. **Usa transacciones** para cambios múltiples
4. **Valida datos** antes de insertar

### 🔍 Depuración:
1. **Construye consultas paso a paso**
2. **Usa subconsultas temporales** para entender resultados
3. **Verifica tipos de datos** en comparaciones
4. **Cuenta filas** antes y después de modificaciones

===============================================================================

## RECURSOS ADICIONALES

### Funciones de Fecha Útiles (SQLite):
- `DATE('now')` - Fecha actual
- `DATETIME('now')` - Fecha y hora actual
- `strftime('%Y-%m', fecha)` - Formatear fecha
- `DATE('now', '+1 day')` - Fecha futura/pasada

### Funciones de Texto:
- `LENGTH(texto)` - Longitud del texto
- `UPPER(texto)` - Convertir a mayúsculas
- `LOWER(texto)` - Convertir a minúsculas
- `SUBSTR(texto, inicio, longitud)` - Extraer subtexto

### Operadores Útiles:
- `||` - Concatenar texto: `nombre || ' - ' || email`
- `COALESCE(valor1, valor2)` - Primer valor no nulo
- `CASE WHEN condición THEN valor ELSE otro_valor END`

===============================================================================

## EJERCICIOS DE PRÁCTICA SUGERIDOS

### Nivel Principiante:
1. Lista todos los productos ordenados por precio
2. Encuentra usuarios cuyo nombre empiece con 'A'
3. Cuenta cuántos productos hay por categoría
4. Encuentra el producto más caro

### Nivel Intermedio:
1. Usuarios que han comprado productos de más de $100
2. Productos que se han vendido más de 2 veces
3. Categoría con mayor valor de inventario
4. Clientes con más de 2 compras

### Nivel Avanzado:
1. Top 3 clientes por gasto total con detalles de compras
2. Productos con mejor rotación (ventas vs stock)
3. Análisis mensual de crecimiento de ventas
4. Productos recomendados por compras relacionadas

¡Estos ejemplos te darán una base sólida para dominar SQL!
Practica cada ejemplo y experimenta con variaciones.

===============================================================================
NOTA PARA ESTUDIANTES:
- Copia y pega cada ejemplo en el sistema web
- Ejecuta las consultas paso a paso
- Modifica los ejemplos para experimentar
- Pregunta si algo no está claro

NOTA PARA INSTRUCTORES:
- Use estos ejemplos como base para explicaciones
- Adapte la complejidad según el nivel del grupo
- Fomente la experimentación y preguntas
- Relacione cada ejemplo con casos de uso reales
===============================================================================